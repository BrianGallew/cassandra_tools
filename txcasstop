#! /usr/bin/env python
"""Cassandra "top" implementation using Twisted.  Queries the Cassandra
JMX status information via MX4J, which must be installed on every Cassandra
node.

:author: Brian Gallew <bgallew@llnw.com> or <geek@gallew.org>

Starter source from the Python script template at
https://github.com/BrianGallew/script_templates/blob/master/template.py

MX4J is http://mx4j.sourceforge.net/

"""

import logging
import logging.handlers
# Requires Python 2.7 or better
import argparse
# actual application required imports

import sys
import xmltodict
import urllib2
import re
import curses
import time
import socket
import collections
import signal
import termios
import pprint
import types
from log_exceptions import log_exceptions  # Debugging tool

# Yay, Twisted!
from twisted.internet import reactor
from twisted.internet.task import LoopingCall
from twisted.web.client import getPage
from twisted.internet.error import ReactorNotRunning

# Globals are bad and I should be ashamed.  But they're so *useful*!
endpoints = {}                  # All Cassandra endpoints
start_time = 0.0
end_time = 0.0
ATTRIBUTE = 'Attribute'
CLASSNAME = '@classname'


def add_summary(functions, key, summary):
    '''Decorator to be used on the various methods in the Screen class which
    are to be exposed via help.
    :param functions: Dict to be updated
    :param key: Keystroke to invoke the method
    :param summary: Help screen text for this method
    :returns: decorator which does the actual update

    I suppose if I were more clever I'd make this a class function, but I
    think it's actually more appropriate to put this out here.

    '''
    def real_decorator(func):
        functions[key] = func
        func.summary = summary
        return func
    return real_decorator


class MovingAverages(object):

    '''Handle moving averages as often displayed by programs like top(8).'''

    def __init__(self):
        self.queue = collections.deque()  # Where we keep our data stashed away
        self.one = self.five = self.fifteen = 0.0
        return

    def add(self, value):
        '''Add a new value, timestamped appropriately.  Throw away any old
        values, then re-compute the moving averages.'''
        if value == None:
            value = 0.0
        now = time.time()
        self.queue.appendleft((value, now))
        # These two lines discard old stuff
        old = now - 900         # 15 minutes
        while self.queue and self.queue[-1][1] < old:
            del self.queue[-1]
        total = 0.0
        count = 0

        then = now - 60
        while count < len(self.queue):
            value, timestamp = self.queue[count]
            if timestamp < then:
                break
            count += 1
            total += value
        self.one = total / count

        then = now - 300
        while count < len(self.queue):
            value, timestamp = self.queue[count]
            if timestamp < then:
                break
            count += 1
            total += value
        self.five = total / count

        while count < len(self.queue):
            value, timestamp = self.queue[count]
            count += 1
            total += value
        self.fifteen = total / count
        return self


class CursesStdIO:

    """fake fd to be registered as a reader with the twisted reactor.
       Curses classes needing input should extend this

    Taken directly from https://twistedmatrix.com/documents/14.0.0/_downloads/cursesclient.py
    """

    def fileno(self):
        """ We want to select on FD 0 """
        return 0

    def doRead(self):
        """called when input is ready"""

    def logPrefix(self):
        return 'CursesClient'


class Screen(CursesStdIO):

    '''Based on https://twistedmatrix.com/documents/14.0.0/_downloads/cursesclient.py
    '''
    rows = 0
    cols = 0
    lines = []
    delay = 5
    header_data = {}
    screen_data = {}
    ring_name = ''
    help = False
    help_indicator = " Press '?' for help"
    max_sort_key = 0
    sort_key = 0
    functions = {}
    cluster_compaction_averages = MovingAverages()

    def __init__(self):
        self.closed = False

        # set screen attributes
        self.old_tty = termios.tcgetattr(sys.stdin.fileno())
        self.stdscr = curses.initscr()  # initialize curses
        self.stdscr.nodelay(1)  # this is used to make input calls non-blocking
        curses.cbreak()
        self.stdscr.keypad(1)
        curses.curs_set(0)     # no annoying mouse cursor
        signal.signal(signal.SIGWINCH, self.updateSize)

        # create color pair's 1 and 2
        curses.start_color()
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)

        self.updateSize()
        self.paintStatus()
        self.stdscr.refresh()

    def updateSize(self, *_):
        '''SIGWINCH handler'''
        curses.endwin()
        curses.initscr()
        self.rows, self.cols = self.stdscr.getmaxyx()
        logging.info('Updated screen size to (%d,%d)',
                     self.rows, self.cols)
        self.stdscr.erase()
        if self.help:
            self.display_help()
        else:
            # This should draw all the other parts
            self.paintStatus()
        self.stdscr.refresh()
        return

    def connectionLost(self, _):
        self.close()

    def paintHeader(self):
        if not self.header_data:
            return  # No data!

    @add_summary(functions, 'c', 'Cluster Summary')
    def paintClusterRollup(self):
        'Display cluster summary data'
        pass
    current_function = paintClusterRollup

    @add_summary(functions, 'h', 'Host Data')
    def paintHostData(self):
        'Display host data'
        pass

    @add_summary(functions, 's', 'Severity')
    def paintCompactionData(self):
        'Display severity (compaction) data'
        pass

    @add_summary(functions, 'l', 'Load')
    def paintLoadDistribution(self):
        'Display load data'
        pass

    @add_summary(functions, 'r', 'Reads')
    def paintReadStatistics(self):
        'Display read data'
        pass

    @add_summary(functions, 'w', 'Writes')
    def paintWriteStatistics(self):
        'Display write data'
        pass

    @log_exceptions()
    def paintStatus(self):
        '''Paint the status line at the bottom of the screen.
        Refresh schedule/time, current display mode, and help prompt.
        '''
        row = self.rows - 1
        status_message = 'Update frequency: %ds (%0.2f)' % (
            self.delay, end_time - start_time)
        status_message = status_message[:self.cols]
        len_status_message = len(status_message)
        self.stdscr.addstr(
            row, 0, status_message + ' ' * (self.cols - len_status_message - 1), curses.color_pair(1))
        len_screen_name = len(self.current_function.summary)
        len_help_indicator = len(self.help_indicator)
        total_len = len_screen_name + len_help_indicator + 1
        if total_len < self.cols:
            self.stdscr.addstr(row, self.cols - len_screen_name -
                               len_help_indicator - 1, self.current_function.summary, curses.color_pair(2))
        self.stdscr.addstr(
            row, self.cols - len_help_indicator - 1, self.help_indicator, curses.color_pair(1))
        self.stdscr.refresh()

    def reload_data(self):
        '''Re-load all cumulative data.'''
        if not endpoints:
            return  # First run
        if not self.ring_name:
            key = endpoints.keys()[0]
            self.ring_name = endpoints[key].get(
                'org.apache.cassandra.db:type=StorageService', {}).get('ClusterName', '')
        self.paintStatus()
        pass

    @log_exceptions()
    def display_help(self):
        '''Draw the help page.  Try to keep the helpstrings up to date and meaningfull.
        '''
        offset = 4
        helpscr = self.stdscr.subwin(self.rows - 4, self.cols - 4, 2, 2)
        (RESTY, RESTX) = helpscr.getmaxyx()
        helpscr.clrtobot()
        helpscr.box()

        def helpscr_addnstr(y, msg):
            if not RESTY > y + 1:
                return False
            helpscr.addnstr(y, (offset / 2) + 1, msg, RESTX - offset)
            return True

        y = 1
        for msg in [
                'Summary information in the first couple lines is for the entire cluster.',
                '',
                'qQ  : Exit the program (immediately)',
                '?   : This help screen',
                '',
                '+   : Increase the delay between updates (takes effect after next update)',
                '-   : Decrease the delay between updates (takes effect after next update)',
                '',
                '1-9 : Column to sort on (if applicable)',
                '<>  : Sort on previous/next column (if applicable)',
                '']:
            y += 1
            if not helpscr_addnstr(y, msg):
                break
        y += 1
        for key in sorted(self.functions):
            y += 1
            if not helpscr_addnstr(y, '%s   : %s' % (key, self.functions[key].__doc__)):
                break
        helpscr.addstr(RESTY - 1, 3, 'Press any key to leave help')
        helpscr.refresh()
        self.help = helpscr

    @log_exceptions()
    def doRead(self):
        """ Input is ready! """
        curses.noecho()
        key = self.stdscr.getch()  # read a character
        if key > 255:
            return       # We don't really handle special keys
        key = chr(key)   # make it an actual character
        logging.debug('read %s', key)
        if self.help:
            self.help.erase()
            self.help = False
            self.stdscr.refresh()
            # return self.reload_data()
            return
        if key in 'qQ':
            logging.debug('quitting by user request')
            self.close()
            return
        elif key == '+':
            self.delay += 1
        elif key == '-':
            if self.delay > 1:
                self.delay -= 1
        elif key in self.functions:  # This is managed by a decorator
            self.current_function = self.functions[key]
            self.current_function()
        elif key in '1234567890':
            value = (int(key) - 1 + 10) % 10  # Convert to [0..9]
            if self.max_sort_key > value:
                self.sort_key = value
            else:
                self.sort_key = self.max_sort_key
        elif key in '<>':
            if key == '>':
                value = self.sort_key + 1
                if self.max_sort_key > value:
                    self.sort_key = value
                else:
                    self.sort_key = self.max_sort_key
            else:
                value = self.sort_key - 1
                if value < 0:
                    value = 0
                self.sort_key = value
        elif key == '?':
            return self.display_help()
        self.paintStatus()
        self.stdscr.refresh()

    def close(self):
        """ clean up """
        if self.closed:
            return
        curses.nocbreak()
        self.stdscr.keypad(0)
        curses.echo()
        curses.endwin()
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, self.old_tty)
        self.closed = True
        try:
            reactor.stop()
        except ReactorNotRunning:
            pass


def setup_logging(option_group):
    """Sets up logging in a syslog format by log level
    :param option_group: options as returned by the OptionParser
    """
    file_log_format = "%(asctime)s - %(levelname)s - %(message)s"
    logger = logging.getLogger()
    if option_group.debug:
        logger.setLevel(level=logging.DEBUG)
    elif option_group.verbose:
        logger.setLevel(level=logging.INFO)
    else:
        logger.setLevel(level=logging.WARNING)

    if option_group.logfile:
        handler = logging.FileHandler(option_group.logfile)
        handler.setFormatter(logging.Formatter(file_log_format))
        logger.addHandler(handler)
    else:
        # Use standard format here because timestamp and level will be added by
        # syslogd.
        logger.addHandler(
            logging.handlers.SysLogHandler(facility=option_group.syslog))
    return


def register_hosts(option_group):
    '''Sets up the global list of hosts.
    '''
    url = 'http://%(seed_host)s:%(mx4j_port)s/getattribute?objectname=org.apache.cassandra.net:type=FailureDetector&attribute=AllEndpointStates&operation=getattribute&template=identity' % vars(
        option_group)
    url = 'http://' + option_group.seed_host + ':' + str(option_group.mx4j_port) + '/getattribute?' + \
        'objectname=org.apache.cassandra.net:type=FailureDetector' + \
        '&attribute=AllEndpointStates' + \
        '&operation=getattribute' + '&template=identity'
    ring_data = xmltodict.parse(urllib2.urlopen(url, None, 30))
    value = ring_data['MBean']['Attribute']['@value']
    for row in re.split('^/', value, flags=re.MULTILINE):
        if not row:
            continue
        if 'STATUS:remov' in row:
            continue
        row_pieces = row.split('\n  ')
        complete_address_set = socket.gethostbyaddr(row_pieces[0])
        endpoint = complete_address_set[0].replace('.cint', '')
        endpoints[endpoint] = {}


@log_exceptions()
def schedule_cluster(option_group, screen):
    '''Schedule calls of all cluster data'''
    # First, update the cluster display to the current state.
    global start_time
    screen.reload_data()
    start_time = time.time()
    # Now, set up Deferreds for all of the URLs that need to be gotten.
    deferreds = []
    for endpoint in endpoints:
        url = 'http://%s:%s/mbean?template=identity&operations=false&constructors=false&notifications=false&' % (
            endpoint, option_group.mx4j_port)
        for query in [
                'objectname=org.apache.cassandra.metrics:type=ClientRequest,scope=*,name=*',
                'objectname=*:type=*'
        ]:
            logging.debug('dispatching GET for %s', url + query)
            deferreds.append(getPage(url + query))
            deferreds[-1].addCallback(parse_data)
            deferreds[-1].addCallback(update_data, endpoint)
    return deferreds


def type_convertor(data_type, data_value):
    '''Convert Java types into Python types.  This is incomplete, but meh.
    '''
    if 'Write-only' in data_value:
        return None
    retval = None
    try:
        if data_type == 'java.lang.String' or data_type == '[Ljava.lang.String':
            retval = data_value
        elif data_type == 'boolean':
            if data_value == 'true':
                retval = True
            else:
                retval = False
        elif data_type == 'int' or data_type == 'long' or data_type == 'java.lang.Long':
            retval = int(data_value)
        elif data_type == 'float' or data_type == 'double':
            retval = float(data_value)
        elif data_type == 'java.util.List' or data_type == 'java.util.Set':
            retval = [x.strip() for x in data_value[1:-1].split(',')]
        elif data_type == 'java.util.Map':
            map_value = {}
            for line in data_value[1:-1].split(','):
                x, y = line.split('=')
                map_value[x.strip()] = y.strip()
            # Do the assignment last in case of an exception
            retval = map_value
        else:
            # I don't care about any of the remaining types at this
            # point.  I hope.
            logging.info('Unknown type: %s:%s', data_type, data_value)
    except Exception as e:
        logging.info(
            'Exception processing: %s:%s (%s)', data_type, data_value, e)
    return retval


@log_exceptions()
def parse_data(xml_blob):
    global end_time
    data = xmltodict.parse(xml_blob)['Server']['MBean']
    converted_data = {}
    for bean in data:
        if not ATTRIBUTE in bean:
            # Some mbeans don't have attributes (e.g.
            # org.apache.cassandra.net:type=Gossiper)
            continue
        label = bean['@objectname']
        # SchemaVersions is ... special.
        if '@name' in bean and bean['@name'] == 'SchemaVersions':
            converted_data['SchemaVersions'] = bean['@value']
            continue
        converted_data[label] = {}
        a_type = type(bean[ATTRIBUTE])
        if a_type == types.ListType:
            for data_item in bean[ATTRIBUTE]:
                try:
                    converted_data[label][data_item['@name']] = type_convertor(
                        data_item['@type'], data_item['@value'])
                    logging.debug(
                        '%s:%s', label, converted_data[label][data_item['@name']])
                except:
                    logging.warn(
                        'Error converting %s:%s', bean['@objectname'], data_item)
        elif a_type == collections.OrderedDict:
            data_item = bean[ATTRIBUTE]
            try:
                converted_data[label][data_item['@name']] = type_convertor(
                    data_item['@type'], data_item['@value'])
                logging.debug(
                    '%s:%s', label, converted_data[label][data_item['@name']])
            except:
                logging.warn(
                    'Error converting %s:%s', bean['@objectname'], data_item)
        else:
            logging.critical(
                'No handler for %s: type %s', str(bean), a_type)
    end_time = time.time()
    return converted_data


def update_data(datadict, endpoint):
    # There are a few odd types in the master data that need to be updated
    # intelligently rather than just being blindly overwritten.
    for objectclass, attribute in [
            ['org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Latency',
                '75thPercentile'],
            ['org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Latency',
                '75thPercentile'],
            ['org.apache.cassandra.metrics:type=ClientRequest,scope=RangeSlice,name=Latency',
                '75thPercentile'],
            ['org.apache.cassandra.db:type=DynamicEndpointSnitch', 'Severity']
    ]:
        if objectclass in datadict:
            try:
                average = endpoints[endpoint][objectclass][attribute]
            except:
                average = MovingAverages()
            average.add(datadict[objectclass][attribute])
            datadict[objectclass][attribute] = average
    endpoints[endpoint].update(datadict)
    logging.debug('%s: %s', endpoint, pprint.pformat(endpoints[endpoint]))
    return


def cli():
    '''Put argument selection/parsing in here for neatness
    '''
    parser = argparse.ArgumentParser()
    # Standard logging options.
    parser.add_argument("-v", "--verbose", dest="verbose", action='store_true',
                        default=False, help="Verbose output")
    parser.add_argument("-d", "--debug", dest="debug", action='store_true',
                        default=False, help="Debugging output, also opens a telnet server on port localhost:2222 with admin/aaa")
    parser.add_argument("--syslog", dest="syslog", metavar="FACILITY",
                        help="Send log messages to the syslog (default USER if neither syslog nor logfile are specified)")
    parser.add_argument("--logfile", dest="logfile", metavar="FILENAME",
                        help="Send log messages to a file")
    # script-specific options here
    parser.add_argument("--mx4j-port", metavar="PORT", default=8081,
                        help="Port number on which MX4J listens")
    parser.add_argument(dest='seed_host', metavar="SEED_HOST",
                        help="Functional member of the Cassandra cluster")

    options = parser.parse_args()
    setup_logging(options)
    return options


def main():
    """Primary entry point."""
    options = cli()

    # Your code here.
    print 'getting node list'
    register_hosts(options)
    screen = Screen()   # create Screen object
    try:
        # add screen object as a reader to the reactor
        lc = LoopingCall(schedule_cluster, options, screen)
        lc.start(screen.delay)
        reactor.addReader(screen)
        if options.debug:
            import twisted.manhole.telnet
            f = twisted.manhole.telnet.ShellFactory()
            f.username = "admin"
            f.password = "aaa"
            f.namespace['foo'] = 12
            reactor.listenTCP(2222, f, interface='localhost')

        # reactor.connectTCP("irc.freenode.net",6667,ircFactory) # connect to
        # IRC
        reactor.run()  # have fun!
    except Exception as e:
        raise e
    screen.close()              # Just in case!

    return


if __name__ == '__main__':
    main()
