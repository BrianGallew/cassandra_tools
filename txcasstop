#! /usr/bin/env python
"""Cassandra "top" implementation using Twisted.  Queries the Cassandra
JMX status information via MX4J, which must be installed on every Cassandra
node.

:author: Brian Gallew <bgallew@llnw.com> or <geek@gallew.org>

Starter source from the Python script template at
https://github.com/BrianGallew/script_templates/blob/master/template.py

MX4J is http://mx4j.sourceforge.net/

"""

import logging
import logging.handlers
# Requires Python 2.7 or better
import argparse
# actual application required imports

import sys
import xmltodict
import urllib2
import optparse
import threading
import re
import curses
import time
import socket
import json
import collections
import traceback
import signal
import termios
import pprint

# Yay, Twisted!
from twisted.internet import reactor
from twisted.internet.task import LoopingCall
from twisted.web.client import getPage

endpoints = {}                  # All Cassandra endpoints


class CursesStdIO:

    """fake fd to be registered as a reader with the twisted reactor.
       Curses classes needing input should extend this

    Taken directly from https://twistedmatrix.com/documents/14.0.0/_downloads/cursesclient.py
    """

    def fileno(self):
        """ We want to select on FD 0 """
        return 0

    def doRead(self):
        """called when input is ready"""

    def logPrefix(self):
        return 'CursesClient'


class Screen(CursesStdIO):

    '''Based on https://twistedmatrix.com/documents/14.0.0/_downloads/cursesclient.py
    '''
    rows = 0
    cols = 0
    lines = []

    def __init__(self):
        self.timer = 0
        self.statusText = "TEST CURSES APP -"
        self.searchText = ''
        self.closed = False

        # set screen attributes
        self.old_tty = termios.tcgetattr(sys.stdin.fileno())
        self.stdscr = curses.initscr()  # initialize curses
        self.stdscr.nodelay(1)  # this is used to make input calls non-blocking
        curses.cbreak()
        self.stdscr.keypad(1)
        curses.curs_set(0)     # no annoying mouse cursor

        signal.signal(signal.SIGWINCH, self.updateSize)
        self.updateSize()

        curses.start_color()

        # create color pair's 1 and 2
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)

        self.paintStatus(self.statusText)
        self.stdscr.refresh()

    def updateSize(self, *_):
        self.rows, self.cols = self.stdscr.getmaxyx()

    def connectionLost(self, reason):
        self.close()

    def addLine(self, text):
        """ add a line to the internal list of lines"""

        self.lines.append(text)
        self.redisplayLines()

    def redisplayLines(self):
        """ method for redisplaying lines 
            based on internal list of lines """

        self.stdscr.clear()
        self.paintStatus(self.statusText)
        i = 0
        index = len(self.lines) - 1
        while i < (self.rows - 3) and index >= 0:
            self.stdscr.addstr(self.rows - 3 - i, 0, self.lines[index],
                               curses.color_pair(2))
            i = i + 1
            index = index - 1
        self.stdscr.refresh()

    def paintStatus(self, text):
        if len(text) > self.cols:
            text = text[:self.cols]
        self.stdscr.addstr(self.rows - 2, 0, text + ' ' * (self.cols - len(text)),
                           curses.color_pair(1))
        # move cursor to input line
        self.stdscr.move(self.rows - 1, self.cols - 1)
        self.stdscr.refresh()

    def doRead(self):
        """ Input is ready! """
        curses.noecho()
        self.timer = self.timer + 1
        c = self.stdscr.getch()  # read a character

        if c == curses.KEY_BACKSPACE:
            self.searchText = self.searchText[:-1]

        elif c == curses.KEY_ENTER or c == 10:
            self.addLine(self.searchText)
            # for testing too
            try:
                self.irc.sendLine(self.searchText)
            except:
                pass
            self.stdscr.refresh()
            self.searchText = ''

        else:
            if len(self.searchText) == self.cols - 2:
                return
            self.searchText = self.searchText + chr(c)

        self.stdscr.addstr(self.rows - 1, 0,
                           self.searchText + (' ' * (
                               self.cols - len(self.searchText) - 2)))
        self.stdscr.move(self.rows - 1, len(self.searchText))
        self.paintStatus(self.statusText + ' %d' % len(self.searchText))
        self.stdscr.refresh()

    def close(self):
        """ clean up """
        if self.closed:
            return
        curses.nocbreak()
        self.stdscr.keypad(0)
        curses.echo()
        curses.endwin()
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, self.old_tty)
        self.closed = True


def setup_logging(option_group):
    """Sets up logging in a syslog format by log level
    :param option_group: options as returned by the OptionParser
    """
    stderr_log_format = "%(levelname) -8s %(asctime)s %(funcName)s line:%(lineno)d: %(message)s"
    file_log_format = "%(asctime)s - %(levelname)s - %(message)s"
    logger = logging.getLogger()
    if option_group.debug:
        logger.setLevel(level=logging.DEBUG)
    elif option_group.verbose:
        logger.setLevel(level=logging.INFO)
    else:
        logger.setLevel(level=logging.WARNING)

    handlers = []
    if option_group.logfile:
        handler = logging.FileHandler(option_group.logfile)
        handler.setFormatter(logging.Formatter(file_log_format))
        logger.addHandler(handler)
    else:
        facility = option_group.syslog or 'USER'
        # Use standard format here because timestamp and level will be added by
        # syslogd.
        logger.addHandler(
            logging.handlers.SysLogHandler(facility=option_group.syslog))
    return


def mx4j_query(hostname, objectname, attribute, operation):
    '''Call out to MX4J, return a dictionary.
    '''
    url_template = 'http://{Hostname:s}:8081/{OPERATION:s}?objectname={JAVA_OBJECT:s}&attribute={ITEM:s}&operation={ITEM:s}&template=identity'
    bean_designator = 'MBean'
    return_value_designators = ['Attribute', '@value']
    default_value = 0
    operation = 'getattribute'
    datatype = int
    default_format = '{VALUE:>4d}'

    # def __init__(self, hostname, java_object, item, *args, **kwargs):
    #     '''Set some default values for the dictionary, largely for debugging and interpolation purposes'''
    #     dict.__init__(self, *args, **kwargs)
    #     self[HOSTNAME] = hostname
    #     self[JAVA_OBJECT] = java_object
    #     self[ITEM] = item
    # This seems silly, but it lets subclasses override while still letting
    # us do interpolation.
    #     self[OPERATION] = self.operation
    #     self[URL] = self.url_template.format(**self)
    #     self[VALUE] = self.default_value
    #     return None


def no_host(*_):
    reactor.stop()
    print "Unable to connect to Cassandra"
    return


def register_hosts(xml_blob, screen):
    open('/tmp/foo', 'w').write('1')
    screen.paintStatus('registering hosts')
    time.sleep(1)
    ring_data = xmltodict.parse(xml_blob)
    screen.paintStatus(str(ring_data))
    time.sleep(1)
    open('/tmp/foo', 'w').write(str(ring_data))
    mbean = ring_data['MBean']
    open('/tmp/foo', 'w').write(str(mbean))
    attribute = mbean['Attribute']
    open('/tmp/foo', 'w').write(str(attribute))
    value = attribute['@value']
    open('/tmp/foo', 'w').write(str(value))
    groups = re.split('^/', value, re.MULTILINE)
    screen.paintStatus(str(groups))
    open('/tmp/foo', 'w').write(str(groups))


def wHATEver(error, screen):
    screen.paintStatus(str(error))
    open('/tmp/wHATEver', 'w').write(str(error))


def cluster_diviner(option_group):
    '''Discovers the members of the cluster.  Dead cluster members are never
    removed, but new cluster members will be added.
    See: CursedCluster for what this should do.
    '''
    # http://db-cdev-1.phx3.llnw.net:8081/mbean?objectname=*:type=*&template=identity
    # http://db-cdev-1.phx3.llnw.net:8081/getattribute?objectname=org.apache.cassandra.net:type=FailureDetector&attribute=AllEndpointStates&operation=getattribute&template=identity
    return


def main():
    """Primary entry point."""
    logging.debug('main')
    parser = argparse.ArgumentParser()
    # Standard logging options.
    parser.add_argument("-v", "--verbose", dest="verbose", action='store_true',
                        default=False, help="Verbose output")
    parser.add_argument("-d", "--debug", dest="debug", action='store_true',
                        default=False, help="Debugging output, also opens a telnet server on port localhost:2222 with admin/aaa")
    parser.add_argument("--syslog", dest="syslog", metavar="FACILITY",
                        help="Send log messages to the syslog (default USER if neither syslog nor logfile are specified)")
    parser.add_argument("--logfile", dest="logfile", metavar="FILENAME",
                        help="Send log messages to a file")
    # script-specific options here
    parser.add_argument("--mx4j-port", metavar="PORT", default=8081,
                        help="Port number on which MX4J listens")
    parser.add_argument(dest='seed_host', metavar="SEED_HOST",
                        help="Functional member of the Cassandra cluster")

    options = parser.parse_args()
    setup_logging(options)

    # Your code here.
    print 'getting node list'
    print 'setting up curses'
    d = getPage(
        'http://%(seed_host)s:%(mx4j_port)s/getattribute?objectname=org.apache.cassandra.net:type=FailureDetector&attribute=AllEndpointStates&operation=getattribute&template=identity' % vars(options))
    print d
    screen = Screen()   # create Screen object
    d.addCallbacks(register_hosts, no_host, callbackArgs=[screen, ])
    d.addErrback(wHATEver, screen)
    try:
        # add screen object as a reader to the reactor
        #LoopingCall(cluster_diviner, options)
        reactor.addReader(screen)
        if options.debug:
            import twisted.manhole.telnet
            f = twisted.manhole.telnet.ShellFactory()
            f.username = "admin"
            f.password = "aaa"
            f.namespace['foo'] = 12
            reactor.listenTCP(2222, f, interface='localhost')

        # reactor.connectTCP("irc.freenode.net",6667,ircFactory) # connect to
        # IRC
        reactor.run()  # have fun!
    except Exception as e:
        raise e
    screen.close()

    return


if __name__ == '__main__':
    main()
