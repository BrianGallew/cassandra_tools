#! /usr/bin/env python
"""Cassandra "top" implementation using Twisted.  Queries the Cassandra
JMX status information via MX4J, which must be installed on every Cassandra
node.

:author: Brian Gallew <bgallew@llnw.com> or <geek@gallew.org>

Starter source from the Python script template at
https://github.com/BrianGallew/script_templates/blob/master/template.py

MX4J is http://mx4j.sourceforge.net/

"""

import logging
import logging.handlers
# Requires Python 2.7 or better
import argparse
# actual application required imports

import sys
import xmltodict
import urllib2
import optparse
import threading
import re
import curses
import time
import socket
import json
import collections
import traceback
import signal
import termios
import pprint

# Yay, Twisted!
from twisted.internet import reactor
from twisted.internet.task import LoopingCall
from twisted.web.client import getPage

endpoints = {}                  # All Cassandra endpoints
ATTRIBUTE = 'Attribute'
CLASSNAME = '@classname'


class CursesStdIO:

    """fake fd to be registered as a reader with the twisted reactor.
       Curses classes needing input should extend this

    Taken directly from https://twistedmatrix.com/documents/14.0.0/_downloads/cursesclient.py
    """

    def fileno(self):
        """ We want to select on FD 0 """
        return 0

    def doRead(self):
        """called when input is ready"""

    def logPrefix(self):
        return 'CursesClient'


class Screen(CursesStdIO):

    '''Based on https://twistedmatrix.com/documents/14.0.0/_downloads/cursesclient.py
    '''
    rows = 0
    cols = 0
    lines = []
    delay = 5

    def __init__(self):
        self.timer = 0
        self.statusText = "TEST CURSES APP -"
        self.searchText = ''
        self.closed = False

        # set screen attributes
        self.old_tty = termios.tcgetattr(sys.stdin.fileno())
        self.stdscr = curses.initscr()  # initialize curses
        self.stdscr.nodelay(1)  # this is used to make input calls non-blocking
        curses.cbreak()
        self.stdscr.keypad(1)
        curses.curs_set(0)     # no annoying mouse cursor
        signal.signal(signal.SIGWINCH, self.updateSize)
        self.updateSize()
        curses.start_color()

        # create color pair's 1 and 2
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(2, curses.COLOR_CYAN, curses.COLOR_BLACK)

        self.paintStatus(self.statusText)
        self.stdscr.refresh()

    def updateSize(self, *_):
        self.rows, self.cols = self.stdscr.getmaxyx()

    def connectionLost(self, reason):
        self.close()

    def addLine(self, text):
        """ add a line to the internal list of lines"""

        self.lines.append(text)
        self.redisplayLines()

    def redisplayLines(self):
        """ method for redisplaying lines 
            based on internal list of lines """

        self.stdscr.clear()
        self.paintStatus(self.statusText)
        i = 0
        index = len(self.lines) - 1
        while i < (self.rows - 3) and index >= 0:
            self.stdscr.addstr(self.rows - 3 - i, 0, self.lines[index],
                               curses.color_pair(2))
            i = i + 1
            index = index - 1
        self.stdscr.refresh()

    def paintStatus(self, text):
        if len(text) > self.cols:
            text = text[:self.cols]
        self.stdscr.addstr(self.rows - 2, 0, text + ' ' * (self.cols - len(text)),
                           curses.color_pair(1))
        # move cursor to input line
        self.stdscr.move(self.rows - 1, self.cols - 1)
        self.stdscr.refresh()

    def doRead(self):
        """ Input is ready! """
        curses.noecho()
        self.timer = self.timer + 1
        c = self.stdscr.getch()  # read a character

        if c == curses.KEY_BACKSPACE:
            self.searchText = self.searchText[:-1]

        elif c == curses.KEY_ENTER or c == 10:
            self.addLine(self.searchText)
            # for testing too
            try:
                self.irc.sendLine(self.searchText)
            except:
                pass
            self.stdscr.refresh()
            self.searchText = ''

        else:
            if len(self.searchText) == self.cols - 2:
                return
            self.searchText = self.searchText + chr(c)

        self.stdscr.addstr(self.rows - 1, 0,
                           self.searchText + (' ' * (
                               self.cols - len(self.searchText) - 2)))
        self.stdscr.move(self.rows - 1, len(self.searchText))
        self.paintStatus(self.statusText + ' %d' % len(self.searchText))
        self.stdscr.refresh()

    def close(self):
        """ clean up """
        if self.closed:
            return
        curses.nocbreak()
        self.stdscr.keypad(0)
        curses.echo()
        curses.endwin()
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, self.old_tty)
        self.closed = True


def setup_logging(option_group):
    """Sets up logging in a syslog format by log level
    :param option_group: options as returned by the OptionParser
    """
    stderr_log_format = "%(levelname) -8s %(asctime)s %(funcName)s line:%(lineno)d: %(message)s"
    file_log_format = "%(asctime)s - %(levelname)s - %(message)s"
    logger = logging.getLogger()
    if option_group.debug:
        logger.setLevel(level=logging.DEBUG)
    elif option_group.verbose:
        logger.setLevel(level=logging.INFO)
    else:
        logger.setLevel(level=logging.WARNING)

    handlers = []
    if option_group.logfile:
        handler = logging.FileHandler(option_group.logfile)
        handler.setFormatter(logging.Formatter(file_log_format))
        logger.addHandler(handler)
    else:
        facility = option_group.syslog or 'USER'
        # Use standard format here because timestamp and level will be added by
        # syslogd.
        logger.addHandler(
            logging.handlers.SysLogHandler(facility=option_group.syslog))
    return


def register_hosts(option_group):
    '''Sets up the global list of hosts.
    '''
    url = 'http://%(seed_host)s:%(mx4j_port)s/getattribute?objectname=org.apache.cassandra.net:type=FailureDetector&attribute=AllEndpointStates&operation=getattribute&template=identity' % vars(
        option_group)
    ring_data = xmltodict.parse(urllib2.urlopen(url, None, 30))
    value = ring_data['MBean']['Attribute']['@value']
    for row in re.split('^/', value, flags=re.MULTILINE):
        if not row:
            continue
        if 'STATUS:remov' in row:
            continue
        row_pieces = row.split('\n  ')
        complete_address_set = socket.gethostbyaddr(row_pieces[0])
        endpoint = complete_address_set[0].replace('.cint', '')
        endpoints[endpoint] = complete_address_set


def schedule_cluster(option_group):
    '''Schedule calls of all cluster data'''
    deferreds = []
    for endpoint in endpoints:
        deferreds.append(getPage(
            'http://%s:%s/mbean?objectname=*:type=*&template=identity' % (endpoint, option_group.mx4j_port)))
        deferreds[-1].addCallback(parse_data)
        deferreds[-1].addCallback(update_data, endpoint)
        return deferreds[-1]
    return deferreds


def type_convertor(data_type, data_value):
    '''Convert Java types into Python types.  This is incomplete, but meh.
    '''
    try:
        if data_type == 'java.lang.String' or data_type == '[Ljava.lang.String':
            return data_value
        elif data_type == 'boolean':
            if data_value == 'true':
                return True
            else:
                return False
        elif data_type == 'int' or data_type == 'long' or data_type == 'java.lang.Long':
            return int(data_value)
        elif data_type == 'float' or data_type == 'double':
            return float(data_value)
        elif data_type == 'java.util.List' or data_type == 'java.util.Set':
            return [x.strip() for x in data_value[1:-1].split(',')]
        elif data_type == 'java.util.Map':
            map_value = {}
            for line in data_value[1:-1].split(','):
                x, y = line.split('=')
                map_value[x.strip()] = y.strip()
            return map_value
        else:
            # I don't care about any of the remaining types at this
            # point.  I hope.
            logging.info('Unknown type: %s:%s', data_type, data_value)
    except Exception as e:
        logging.info(
            'Exception processing: %s:%s (%s)', data_type, data_value, e)
    return None


def parse_data(xml_blob):
    data = xmltodict.parse(xml_blob)['Server']['MBean']
    converted_data = {}
    for bean in data:
        label = bean[CLASSNAME]
        if label in ['org.apache.cassandra.db.BatchlogManager', 'org.apache.cassandra.locator.EndpointSnitchInfo']:
            try:
                converted_data.setdefault(
                    label, {})[bean[ATTRIBUTE]['@name']] = bean[ATTRIBUTE]['@value']
            except:
                logging.warning('BEGIN %s\n%s\nEND %s', label, bean,  label)
            continue
        if '@name' in bean and bean['@name'] == 'SchemaVersions':
            converted_data['SchemaVersions'] = bean['@value']
            continue
        converted_data[label] = {}
        if not ATTRIBUTE in bean:
            if not 'Operation' in bean:
                logging.info('STUPIDITY: %s' % str(bean))
            continue
        for data_item in bean[ATTRIBUTE]:
            converted_data[label][data_item['@name']] = type_convertor(
                data_item['@type'], data_item['@value'])
            logging.debug(
                '%s:%s', label, converted_data[label][data_item['@name']])
    return converted_data


def update_data(datadict, endpoint):
    logging.debug('%s: %s', endpoint, pprint.pformat(datadict))
    # There are a few odd types in the master data that need to be updated
    # intelligently rather than just being blindly overwritten.
    # READ_LATENCY_INSTANTANEOUS:
    #     (CursedLatencyAverage,
    #      ('org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Latency', '75thPercentile')),
    # WRITE_LATENCY_INSTANTANEOUS:
    #     (CursedLatencyAverage,
    #      ('org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Latency', '75thPercentile')),
    # self.compaction_averages.add(compaction_data)

    return


def cli():
    '''Put argument selection/parsing in here for neatness
    '''
    parser = argparse.ArgumentParser()
    # Standard logging options.
    parser.add_argument("-v", "--verbose", dest="verbose", action='store_true',
                        default=False, help="Verbose output")
    parser.add_argument("-d", "--debug", dest="debug", action='store_true',
                        default=False, help="Debugging output, also opens a telnet server on port localhost:2222 with admin/aaa")
    parser.add_argument("--syslog", dest="syslog", metavar="FACILITY",
                        help="Send log messages to the syslog (default USER if neither syslog nor logfile are specified)")
    parser.add_argument("--logfile", dest="logfile", metavar="FILENAME",
                        help="Send log messages to a file")
    # script-specific options here
    parser.add_argument("--mx4j-port", metavar="PORT", default=8081,
                        help="Port number on which MX4J listens")
    parser.add_argument(dest='seed_host', metavar="SEED_HOST",
                        help="Functional member of the Cassandra cluster")

    options = parser.parse_args()
    setup_logging(options)
    return options


def main():
    """Primary entry point."""
    options = cli()

    # Your code here.
    print 'getting node list'
    register_hosts(options)
    screen = Screen()   # create Screen object
    try:
        # add screen object as a reader to the reactor
        lc = LoopingCall(schedule_cluster, options)
        lc.start(screen.delay)
        reactor.addReader(screen)
        if options.debug:
            import twisted.manhole.telnet
            f = twisted.manhole.telnet.ShellFactory()
            f.username = "admin"
            f.password = "aaa"
            f.namespace['foo'] = 12
            reactor.listenTCP(2222, f, interface='localhost')

        # reactor.connectTCP("irc.freenode.net",6667,ircFactory) # connect to
        # IRC
        reactor.run()  # have fun!
    except Exception as e:
        raise e
    screen.close()

    return


if __name__ == '__main__':
    main()
