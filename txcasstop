#! /usr/bin/env python
"""Cassandra "top" implementation using Twisted.  Queries the Cassandra
JMX status information via MX4J, which must be installed on every Cassandra
node.

:author: Brian Gallew <bgallew@llnw.com> or <geek@gallew.org>

Starter source from the Python script template at
https://github.com/BrianGallew/script_templates/blob/master/template.py

MX4J is http://mx4j.sourceforge.net/

"""

import logging
import logging.handlers
# Requires Python 2.7 or better
import argparse
# actual application required imports

import sys
import xmltodict
import urllib2
import re
import curses
import time
import socket
import collections
import signal
import termios
import pprint
import types
from log_exceptions import log_exceptions  # Debugging tool

# Yay, Twisted!
from twisted.internet import reactor
from twisted.internet.task import LoopingCall
from twisted.web.client import getPage
from twisted.internet.error import ReactorNotRunning

# Globals are bad and I should be ashamed.  But they're so *useful*!
endpoints = {}                  # All Cassandra endpoints
start_time = 0.0
end_time = 0.0
ATTRIBUTE = 'Attribute'
CLASSNAME = '@classname'


class MovingAverages(object):

    '''Handle moving averages as often displayed by programs like top(8).'''

    def __init__(self):
        self.queue = collections.deque()  # Where we keep our data stashed away
        self.one = self.five = self.fifteen = 0.0
        return

    def add(self, value):
        '''Add a new value, timestamped appropriately.  Throw away any old
        values, then re-compute the moving averages.'''
        now = time.time()
        self.queue.appendleft((value, now))
        # These two lines discard old stuff
        old = now - 900         # 15 minutes
        while self.queue and self.queue[-1][1] < old:
            del self.queue[-1]
        total = 0.0
        count = 0

        then = now - 60
        while count < len(self.queue):
            value, timestamp = self.queue[count]
            if timestamp < then:
                break
            count += 1
            total += value
        self.one = total / count

        then = now - 300
        while count < len(self.queue):
            value, timestamp = self.queue[count]
            if timestamp < then:
                break
            count += 1
            total += value
        self.five = total / count

        while count < len(self.queue):
            value, timestamp = self.queue[count]
            count += 1
            total += value
        self.fifteen = total / count
        return self


class CursesStdIO:

    """fake fd to be registered as a reader with the twisted reactor.
       Curses classes needing input should extend this

    Taken directly from https://twistedmatrix.com/documents/14.0.0/_downloads/cursesclient.py
    """

    def fileno(self):
        """ We want to select on FD 0 """
        return 0

    def doRead(self):
        """called when input is ready"""

    def logPrefix(self):
        return 'CursesClient'


class Screen(CursesStdIO):

    '''Based on https://twistedmatrix.com/documents/14.0.0/_downloads/cursesclient.py
    '''
    rows = 0
    cols = 0
    lines = []
    delay = 5
    header_data = {}
    screen_data = {}
    ring_name = ''
    help = False
    help_indicator = " Press '?' for help"
    screen_name = 'Unknown'
    max_sort_key = 0
    sort_key = 0
    helpstrings = [
        ('',
         'Summary information in the first couple lines is for the entire cluster.'),
        ('', ''),
        ('q', 'Exit the program (immediately)'),
        ('c', 'Display cluster summary data'),
        ('h', 'Display host data'),
        ('s', 'Display severity (compaction) data'),
        ('l', 'Display load data'),
        ('r', 'Display read data'),
        ('w', 'Display write data'),
        ('', ''),
        ('+',
         'Increase the delay between updates (takes effect after next update)'),
        ('-',
         'Decrease the delay between updates (takes effect after next update)'),
        ('', ''),
        ('1-9', 'Column to sort on, OR switch values sets in read/write data'),
        ('<>',
         'Previous/next sort column, OR switch values sets in read/write data'),
        ('', ''),
        ('?', 'This help screen'),
    ]

    def __init__(self):
        self.closed = False

        # set screen attributes
        self.old_tty = termios.tcgetattr(sys.stdin.fileno())
        self.stdscr = curses.initscr()  # initialize curses
        self.stdscr.nodelay(1)  # this is used to make input calls non-blocking
        curses.cbreak()
        self.stdscr.keypad(1)
        curses.curs_set(0)     # no annoying mouse cursor
        signal.signal(signal.SIGWINCH, self.updateSize)
        self.updateSize()
        curses.start_color()

        # create color pair's 1 and 2
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)

        self.paintStatus()
        self.stdscr.refresh()

    def updateSize(self, *_):
        curses.endwin()
        curses.initscr()
        self.rows, self.cols = self.stdscr.getmaxyx()
        if self.cols < 80:
            raise Exception('At least 80 columns required for display')
        logging.info('Updated screen size to (%d,%d)' %
                     (self.rows, self.cols))

    def connectionLost(self, reason):
        self.close()

    def addLine(self, text):
        """ add a line to the internal list of lines"""

        self.lines.append(text)
        self.redisplayLines()

    def redisplayLines(self):
        """ method for redisplaying lines 
            based on internal list of lines """

        self.stdscr.clear()
        self.paintStatus()
        i = 0
        index = len(self.lines) - 1
        while i < (self.rows - 3) and index >= 0:
            self.stdscr.addstr(self.rows - 3 - i, 0, self.lines[index],
                               curses.color_pair(2))
            i = i + 1
            index = index - 1
        self.stdscr.refresh()

    def paintStatus(self):

        status_message = 'Update frequency: %ds (%0.2f)' % (
            self.delay, end_time - start_time)
        status_message = status_message[:self.cols]
        len_status_message = len(status_message)
        len_screen_name = len(self.screen_name)
        len_help_indicator = len(self.help_indicator)
        total_len = len_status_message + \
            len_screen_name + len_help_indicator + 1
        if total_len < self.cols:
            self.stdscr.addstr(
                self.rows - 1, 0, status_message + ' ' * (self.cols - total_len), curses.color_pair(1))
            self.stdscr.addstr(self.screen_name, curses.color_pair(2))
            self.stdscr.addstr(self.help_indicator, curses.color_pair(1))
        else:
            self.stdscr.addstr(
                self.rows - 1, 0, status_message, curses.color_pair(1))
        # move cursor to input line
        self.stdscr.refresh()

    def reload_data(self):
        '''Re-load all cumulative data.'''
        if not endpoints:
            return  # First run
        if not self.ring_name:
            key = endpoints.keys()[0]
            self.ring_name = endpoints[key].get(
                'org.apache.cassandra.db:type=StorageService', {}).get('ClusterName', '')
        self.paintStatus()
        pass

    @log_exceptions()
    def display_help(self):
        helpscr = self.stdscr.subwin(self.rows - 4, self.cols - 4, 2, 2)
        (RESTY, RESTX) = helpscr.getmaxyx()
        helpscr.clrtobot()
        helpscr.box()
        y = 1
        for parts in self.helpstrings:
            y += 1
            helpscr.addnstr(y, 3, '%s: %s' % parts, RESTX - 4)
        helpscr.addstr(RESTY - 1, 3, 'Press any key to leave help')
        helpscr.refresh()
        self.help = helpscr

    @log_exceptions()
    def doRead(self):
        """ Input is ready! """
        curses.noecho()
        key = self.stdscr.getch()  # read a character
        if key > 255:
            return       # We don't really handle special keys
        key = chr(key)   # make it an actual character
        logging.debug('read %s', key)
        if self.help:
            self.help.erase()
            self.help = False
            self.stdscr.refresh()
            # return self.reload_data()
            return
        if key in 'qQ':
            logging.debug('quitting by user request')
            self.close()
            return
        elif key == '+':
            self.delay += 1
        elif key == '-':
            if self.delay > 1:
                self.delay -= 1
        elif key in 'chslrw':
            self.change_layout(key)
        elif key in '1234567890':
            value = (int(key) - 1 + 10) % 10  # Convert to [0..9]
            if self.max_sort_key > value:
                self.sort_key = value
            else:
                self.sort_key = self.max_sort_key
        elif key in '<>':
            if key == '>':
                value = self.sort_key + 1
                if self.max_sort_key > value:
                    self.sort_key = value
                else:
                    self.sort_key = self.max_sort_key
            else:
                value = self.sort_key - 1
                if value < 0:
                    value = 0
                self.sort_key = value
        elif key == '?':
            return self.display_help()
        self.paintStatus()
        self.stdscr.refresh()

    def close(self):
        """ clean up """
        if self.closed:
            return
        curses.nocbreak()
        self.stdscr.keypad(0)
        curses.echo()
        curses.endwin()
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, self.old_tty)
        self.closed = True
        try:
            reactor.stop()
        except ReactorNotRunning:
            pass


def setup_logging(option_group):
    """Sets up logging in a syslog format by log level
    :param option_group: options as returned by the OptionParser
    """
    file_log_format = "%(asctime)s - %(levelname)s - %(message)s"
    logger = logging.getLogger()
    if option_group.debug:
        logger.setLevel(level=logging.DEBUG)
    elif option_group.verbose:
        logger.setLevel(level=logging.INFO)
    else:
        logger.setLevel(level=logging.WARNING)

    if option_group.logfile:
        handler = logging.FileHandler(option_group.logfile)
        handler.setFormatter(logging.Formatter(file_log_format))
        logger.addHandler(handler)
    else:
        # Use standard format here because timestamp and level will be added by
        # syslogd.
        logger.addHandler(
            logging.handlers.SysLogHandler(facility=option_group.syslog))
    return


def register_hosts(option_group):
    '''Sets up the global list of hosts.
    '''
    url = 'http://%(seed_host)s:%(mx4j_port)s/getattribute?objectname=org.apache.cassandra.net:type=FailureDetector&attribute=AllEndpointStates&operation=getattribute&template=identity' % vars(
        option_group)
    ring_data = xmltodict.parse(urllib2.urlopen(url, None, 30))
    value = ring_data['MBean']['Attribute']['@value']
    for row in re.split('^/', value, flags=re.MULTILINE):
        if not row:
            continue
        if 'STATUS:remov' in row:
            continue
        row_pieces = row.split('\n  ')
        complete_address_set = socket.gethostbyaddr(row_pieces[0])
        endpoint = complete_address_set[0].replace('.cint', '')
        endpoints[endpoint] = {}


@log_exceptions()
def schedule_cluster(option_group, screen):
    '''Schedule calls of all cluster data'''
    # First, update the cluster display to the current state.
    global start_time
    screen.reload_data()
    start_time = time.time()
    # Now, set up Deferreds for all of the URLs that need to be gotten.
    deferreds = []
    for endpoint in endpoints:
        url = 'http://%s:%s/mbean?template=identity&operations=false&constructors=false&notifications=false&' % (
            endpoint, option_group.mx4j_port)
        for query in [
                'objectname=org.apache.cassandra.metrics:type=ClientRequest,scope=*,name=*',
                'objectname=*:type=*'
        ]:
            logging.debug('dispatching GET for %s', url + query)
            deferreds.append(getPage(url + query))
            deferreds[-1].addCallback(parse_data)
            deferreds[-1].addCallback(update_data, endpoint)
    return deferreds


def type_convertor(data_type, data_value):
    '''Convert Java types into Python types.  This is incomplete, but meh.
    '''
    if 'Write-only' in data_value:
        return None
    try:
        if data_type == 'java.lang.String' or data_type == '[Ljava.lang.String':
            return data_value
        elif data_type == 'boolean':
            if data_value == 'true':
                return True
            else:
                return False
        elif data_type == 'int' or data_type == 'long' or data_type == 'java.lang.Long':
            return int(data_value)
        elif data_type == 'float' or data_type == 'double':
            return float(data_value)
        elif data_type == 'java.util.List' or data_type == 'java.util.Set':
            return [x.strip() for x in data_value[1:-1].split(',')]
        elif data_type == 'java.util.Map':
            map_value = {}
            for line in data_value[1:-1].split(','):
                x, y = line.split('=')
                map_value[x.strip()] = y.strip()
            return map_value
        else:
            # I don't care about any of the remaining types at this
            # point.  I hope.
            logging.info('Unknown type: %s:%s', data_type, data_value)
    except Exception as e:
        logging.info(
            'Exception processing: %s:%s (%s)', data_type, data_value, e)
    return None


@log_exceptions()
def parse_data(xml_blob):
    global end_time
    data = xmltodict.parse(xml_blob)['Server']['MBean']
    converted_data = {}
    for bean in data:
        if not ATTRIBUTE in bean:
            # Some mbeans don't have attributes (e.g.
            # org.apache.cassandra.net:type=Gossiper)
            continue
        label = bean['@objectname']
        # SchemaVersions is ... special.
        if '@name' in bean and bean['@name'] == 'SchemaVersions':
            converted_data['SchemaVersions'] = bean['@value']
            continue
        converted_data[label] = {}
        a_type = type(bean[ATTRIBUTE])
        if a_type == types.ListType:
            for data_item in bean[ATTRIBUTE]:
                try:
                    converted_data[label][data_item['@name']] = type_convertor(
                        data_item['@type'], data_item['@value'])
                    logging.debug(
                        '%s:%s', label, converted_data[label][data_item['@name']])
                except:
                    logging.warn(
                        'Error converting %s:%s', bean['@objectname'], data_item)
        elif a_type == collections.OrderedDict:
            data_item = bean[ATTRIBUTE]
            try:
                converted_data[label][data_item['@name']] = type_convertor(
                    data_item['@type'], data_item['@value'])
                logging.debug(
                    '%s:%s', label, converted_data[label][data_item['@name']])
            except:
                logging.warn(
                    'Error converting %s:%s', bean['@objectname'], data_item)
        else:
            logging.critical(
                'No handler for %s: type %s', str(bean), a_type)
    end_time = time.time()
    return converted_data


def update_data(datadict, endpoint):
    # There are a few odd types in the master data that need to be updated
    # intelligently rather than just being blindly overwritten.
    for objectclass, attribute in [
            ['org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Latency',
                '75thPercentile'],
            ['org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Latency',
                '75thPercentile'],
            ['org.apache.cassandra.metrics:type=ClientRequest,scope=RangeSlice,name=Latency',
                '75thPercentile'],
            ['org.apache.cassandra.db:type=DynamicEndpointSnitch', 'Severity']
    ]:
        if objectclass in datadict:
            try:
                ma = endpoints[endpoint][objectclass][attribute]
            except:
                ma = MovingAverages()
            ma.add(datadict[objectclass][attribute])
            datadict[objectclass][attribute] = ma
    endpoints[endpoint].update(datadict)
    logging.debug('%s: %s', endpoint, pprint.pformat(endpoints[endpoint]))
    return


def cli():
    '''Put argument selection/parsing in here for neatness
    '''
    parser = argparse.ArgumentParser()
    # Standard logging options.
    parser.add_argument("-v", "--verbose", dest="verbose", action='store_true',
                        default=False, help="Verbose output")
    parser.add_argument("-d", "--debug", dest="debug", action='store_true',
                        default=False, help="Debugging output, also opens a telnet server on port localhost:2222 with admin/aaa")
    parser.add_argument("--syslog", dest="syslog", metavar="FACILITY",
                        help="Send log messages to the syslog (default USER if neither syslog nor logfile are specified)")
    parser.add_argument("--logfile", dest="logfile", metavar="FILENAME",
                        help="Send log messages to a file")
    # script-specific options here
    parser.add_argument("--mx4j-port", metavar="PORT", default=8081,
                        help="Port number on which MX4J listens")
    parser.add_argument(dest='seed_host', metavar="SEED_HOST",
                        help="Functional member of the Cassandra cluster")

    options = parser.parse_args()
    setup_logging(options)
    return options


def main():
    """Primary entry point."""
    options = cli()

    # Your code here.
    print 'getting node list'
    register_hosts(options)
    screen = Screen()   # create Screen object
    try:
        # add screen object as a reader to the reactor
        lc = LoopingCall(schedule_cluster, options, screen)
        lc.start(screen.delay)
        reactor.addReader(screen)
        if options.debug:
            import twisted.manhole.telnet
            f = twisted.manhole.telnet.ShellFactory()
            f.username = "admin"
            f.password = "aaa"
            f.namespace['foo'] = 12
            reactor.listenTCP(2222, f, interface='localhost')

        # reactor.connectTCP("irc.freenode.net",6667,ircFactory) # connect to
        # IRC
        reactor.run()  # have fun!
    except Exception as e:
        raise e
    screen.close()              # Just in case!

    return


if __name__ == '__main__':
    main()
